测试 seajs 加载其他模块的规则
主要是要测试，如果一个页面的模块要生成多个子包（里面是匹配到的模块），应该如何保证子包被加载然后被作为一个普通文件被执行，

**结论：**
---
1. seajs 从主入口文件开始（seajs.use），每加载一个文件都会：

- 如果没有第一个参数（类型：String），则用一定的手段得到这个文件的绝对路径
（当多个文件同时被加载成功，怎么才能从JS文件被执行时知道自己是哪一个script标签呢？在低级浏览器下并没有办法保证100%的得到正确的绝对路径），
并作为此模块（如果文件存在超过两个模块，且都无ID，此文件仅仅被执行一遍而已（factory回调函数并不会被执行））的ID缓存起来。

- 如果没有第二个参数（类型：Array），则将factory函数 toString 为字符串，然后正则匹配 require 关键字
（因此 seajs 要求这一步页面中不能使用变量），得到每个模块依赖哪些模块，然后在 factory 回调函数前先加载并缓存好这些依赖模块。

- 第三个参数（Function），factory函数是唯一必须的参数

seajs 与 requirejs 的其中一个重要区别就是，seajs拿到一个模块并不会立即执行这个模块的 factory 函数，并达到这个模块的exports，
而是先缓存，等到 require 这个模块的时候，才会去执行这个函数。
而 requirejs 是拿到模块后立即执行并得到 return 的值。

2. 如果模块传递了超过一个参数，且非最后一个是数组的话，就认为这个参数是次模块的依赖，那么，seajs 就不会通过 toString 这个 factory
函数来拿到依赖，而是是用这个数组。
如果这个依赖写的不全，在 require 的时候无法找到这个模块的缓存，也不会另外发起请求。
如果这个依赖写的过多，则会在一开始就发出额外的请求，所以，需要这个 依赖数组写的非常准确才行。

3. 真实模块和虚拟模块。
一个最终ID被解析为A 的模块即为真实模块，
最终没有得到ID的就是虚拟模块，只有 uri 路径

比如，文件 A 中包含模块 B、C，B 和 C 最终都会得到ID，而 A 因为只是一个文件（包、模块的容器）也会被缓存起来，
但是没有ID，只有路径 uri。
